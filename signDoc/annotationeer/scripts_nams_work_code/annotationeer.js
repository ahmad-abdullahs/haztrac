/********************************************************************
 * Copyright (C) 2016-Present Mark Chester Goking <chitgoks@gmail.com>.
 *
 * This file is part of Annotationeer and it can not be copied
 * and/or distributed without the express permission of the author.
 ********************************************************************/

/**
 * This is where all backend related action and integration with the web layer happens.
 * @namespace
 */
var Annotationeer = { };

/**
 * This variable will be assigned when the user is logged in to the system.
 * @memberof Annotationeer
 * @type {string}
 */
Annotationeer.username = 'Username';
Annotationeer.user_name = parent.user_name;
/**
 * The array of PDF Documents. Currently experimental feature showcasing navigating a group of PDFs.
 * @type {Array<PDFDocument>}
 */
Annotationeer.pdfDocuments = [];

Annotationeer.pdfDocumentInfo = new PDFDocument();

// This is a sample code for displaying a lone PDF file
Annotationeer.pdfDocumentInfo.documentId = '1000';
Annotationeer.pdfDocumentInfo.totalPages = 14;
Annotationeer.pdfDocuments.push(Annotationeer.pdfDocumentInfo);

// This is a sample code for displaying a group of PDF files as one.
//Annotationeer.pdfDocumentInfo = new PDFDocument();
//Annotationeer.pdfDocumentInfo.documentId = '3281120';
//Annotationeer.pdfDocumentInfo.totalPages = 6;
//Annotationeer.pdfDocumentInfo.isFirst = true;
//Annotationeer.pdfDocuments.push(Annotationeer.pdfDocumentInfo);
//
//Annotationeer.pdfDocumentInfo = new PDFDocument();
//Annotationeer.pdfDocumentInfo.documentId = '3281120';
//Annotationeer.pdfDocumentInfo.totalPages = 6;
//Annotationeer.pdfDocuments.push(Annotationeer.pdfDocumentInfo);
//
//Annotationeer.pdfDocumentInfo = new PDFDocument();
//Annotationeer.pdfDocumentInfo.documentId = '3281120';
//Annotationeer.pdfDocumentInfo.totalPages = 6;
//Annotationeer.pdfDocumentInfo.isLast = true;
//Annotationeer.pdfDocuments.push(Annotationeer.pdfDocumentInfo);

/**
 * This variable is used to indicate the total number of pages for a single PDF file or group of PDF files.
 * @memberof Annotationeer
 * @type {number}
 */
Annotationeer.aTotalPages = 0;

for (var i=0; i<Annotationeer.pdfDocuments.length; i++) {
  Annotationeer.aTotalPages += Annotationeer.pdfDocuments[i].totalPages;
}

/**
 * This variable is reference to the 1st PDF file of a group or a single PDF file.
 * @memberof Annotationeer
 * @type {string}
 */
Annotationeer.currentDocument = Annotationeer.pdfDocuments[0];
PageManager.consoleLog('document '+Annotationeer.pdfDocuments[0].documentId);
/**
 * This is a global variable of PDF.JS. Override this value for your own to load the PDF file.
 * Per version 1.7 onwards, this is not accessible anymore. Users need to use the query string
 * ?file=[path] option instead. This variable will still be placed for those using < 1.7.
 * @memberof Annotationeer
 * @type {string}
 */
Annotationeer.DEFAULT_URL = Url.docUrl + Annotationeer.pdfDocuments[0].documentId + '.pdf';

/**
 * Ensure that all selected text type e.g. highlight, underline, strike-through are
 * deselected by removing border CSS attribute. Code below will add border if the
 * annotation is selected.
 */
//for (var i=0; i<annotations.length; i++) {
//    var divSet = $('div[id=highlight' + annotations[i].id + ']');
//    for (var d=0; d<divSet.length; d++) {
//        $(divSet[d]).css('border', '');
//    }
//}

/**
 * <p>Helper function to determine if PDF.JS is version 2 and beyond because of
 * functionality changes.</p>
 * @function
 * @memberof Annotationeer
 * @returns {boolean}
 */
Annotationeer.isPDFJSVersion2Plus = function() {
    var version = typeof PDFJS != 'undefined' ? PDFJS.version : 0;

    if(version == 0)
        version = typeof pdfjsLib != 'undefined' ? pdfjsLib.version : 0;

    return Util.versionCompare(version, '2') >= 0;
};

/**
 * Returns the current PDF.JS version.
 * @function
 * @memberof Annotationeer
 * @returns {string|number}
 */
Annotationeer.getPDFJSVersion = function() {
    var version = typeof PDFJS != 'undefined' ? PDFJS.version : 0;

    if(version == 0)
        version = typeof pdfjsLib != 'undefined' ? pdfjsLib.version : 0;

    return version;
};

/**
 * If the current PDF.JS Viewer uses the new event bus model.
 * @function
 * @memberof Annotationeer
 * @returns {boolean}
 */
Annotationeer.isUsingPDFJSEventBus = function() {
    return Util.versionCompare(Annotationeer.getPDFJSVersion(), '2.1') >= 0;
};

/**
 * This function is executed immediately to setup listeners for events generated by PDF.JS.
 */
(Annotationeer.initEventListeners = function() {
    if (Annotationeer.isUsingPDFJSEventBus()) {
        document.addEventListener('webviewerloaded', function() {
            PageManager.consoleLog('webviewerloaded');
            PDFViewerApplicationOptions.set('disablePreferences', true);
            PDFViewerApplicationOptions.set('viewOnLoad', 1);
            PDFViewerApplicationOptions.set('eventBusDispatchToDOM', true);
        }, true);

        document.addEventListener('localized', function() {
            if (PDFViewerApplication.eventBus) {
                PDFViewerApplication.eventBus.on('pagerendered', function(e) {
                     Annotationeer.runAfterPageRendered(e.pageNumber - 1, e.source.scale);
                });

                PDFViewerApplication.eventBus.on('pagechanging', function(e) {
                    Annotationeer.pageChanged(e.pageNumber);
                });

                PDFViewerApplication.eventBus.on('scalechanged', function(e) {
                    var prev = document.getElementById('scaleSelect').getAttribute('prev');
                    if (!prev)
                        return;

                    var prevScale = parseFloat(prev);
                    if (prevScale !== PDFViewerApplication.pdfViewer.currentScale)
                    PageManager.clearAnnotationeerDOMElements();
                });
            }
            else {
                Message.loadTranslations();

                if (PDFViewerApplication.l10n)
                    PDFViewerApplication.l10n.translate($('div#outerContainer')[0]);
            }
        });
    }
    else {
        /**
         * This is the event triggered by PDF.JS whenever a page is rendered which happens when it is visible in the browser.
         */
        document.addEventListener('pagerendered', function(e) {
            Annotationeer.runAfterPageRendered(e.detail.pageNumber - 1);
        }, true);

        document.addEventListener('pagechange', function(e) {
            Annotationeer.pageChanged(e.pageNumber);
        }, true);

        /**
         * Load translations to the Message class. This is only executed once. However, we remove the
         * code that removes the listener since we are not incorporating localization in Annotationeer.
         * If there is no language property file of Annotationeer provided, it will default to en, hence
         * this listener will be used again to reload the message translations to their correct values.
         */
        document.addEventListener('localized', function once() {
            Message.loadTranslations();

            if (PDFViewerApplication.l10n)
                PDFViewerApplication.l10n.translate($('div#outerContainer')[0]);
            //document.removeEventListener('localized', once);
        });
    }

    /**
     * This is triggered when the PDF file is loaded. This is where you call downloadAnnotations() to download all
     * annotations from the server and add them to the PDF pages. The line document.removeEventListener() is not
     * included becaues it causes an error in old verions of Firefox (MacOS, not sure if same occurs in Windows).
     */
    document.addEventListener('DOMContentLoaded', function() {
        PageManager.consoleLog('DOMContentLoaded');
        Annotationeer.setInitialPageBookmark(1);
        Annotationeer.init();
    }, true);

    /**
     * This library will listen to the toolbar annotation height change. This is because if the width gets smaller,
     * the annotation toolbar will spread it out into 2 rows so the positioning of other elements affected will mess
     * up the positioning of annotations when displayed.
     */
    Util.loadScript('ResizeSensor.min.js', function() {
        new ResizeSensor($('div#toolbarAnnotations'), function() {
            PageManager.resizeToolbarBasedOnBrowserWidth();
        });
    });

    /**
     * This event listener is needed because if user creates a drawing and the mouseUp ends up outside the canvas, then
     * the canvas' mouseUp event needs to be called in order to finish drawing.
     */
    document.addEventListener('mouseup', function(e) {
        // The HTMLImageElement here are the buttons in the tool bar.
        // The HTMLCanvasElement here are the annotation layers for each page.
        if (e.srcElement instanceof HTMLCanvasElement || e.srcElement instanceof HTMLImageElement)
            return;

        for (var p in pages) {
            if (!pages.hasOwnProperty(p))
                continue;

            if (pages[p].isCreatingAnnotation || pages[p].isDrawing || PageManager.isResizeDrag) {
                pages[p].canvas.onmouseup(e);
                return;
            }

            for (var i=0; i<pages[p].canvasAnnotations.length; i++) {
                if (pages[p].canvasAnnotations[i].moving) {
                    pages[p].canvas.onmouseup(e);
                    return;
                }
            }
        }
    }, true);

    $(document).ready(function() {
        /**
         * In mobile devices, when change orientation happens, we set the canvas width programmatically so that
         * the mouse position will be correct when creating a signature. However, the canvas itself will clear
         * its contents because it behaves this way.
         *
         * We cannot save the existing signature because the canvas width is different in portrait and landscape mode.
         * Unlike in Acrobat app when the user creates a signature, it forces the orientation to be in landscape mode
         * all the time. There is no way in Javascript to force an orientation change hence what we can do is
         * just reset the canvas.
         */
        window.onresize = function() {
            var canvas = $('#signature');
            if (canvas.length > 0) {
                canvas = canvas[0];
                canvas.width = $('#signature-pad')[0].offsetWidth;
            }
        };

        var viewerContainer = $('#viewerContainer');

        var aPageNumber = $('input#aPageNumber');
        aPageNumber.keypress(function(e) {
            if (e.which == 13) {
                e.preventDefault();
                var page = parseInt(aPageNumber.val());

                if (isNaN(page))
                    return;

                var totalPagesCtr = 0;
                for (var d=0; d<Annotationeer.pdfDocuments.length; d++) {
                    if (totalPagesCtr + Annotationeer.pdfDocuments[d].totalPages >= page) {
                        if (Annotationeer.currentDocument == Annotationeer.pdfDocuments[d])
                            PDFViewerApplication.pdfViewer.currentPageNumber = page;
                        else
                            Annotationeer.reloadPDF(Annotationeer.pdfDocuments[d], page - totalPagesCtr);
                        break;
                    }
                    totalPagesCtr += Annotationeer.pdfDocuments[d].totalPages;
                }
            }
        }).focusout(function() {
            Annotationeer.pageChanged(PDFViewerApplication.pdfViewer.currentPageNumber);
        });

        if (Annotationeer.pdfDocuments && Annotationeer.pdfDocuments.length > 1) {
            var wheelEvent = Util.isEventSupported('mousewheel') ? 'mousewheel' : 'wheel';
            viewerContainer.on(wheelEvent, function(e) {
                if ($('body').hasClass('loadingInProgress') || !$('div.progress').hasClass('indeterminate'))
                    return;

                var oEvent = e.originalEvent;
                var delta = oEvent.deltaY || oEvent.wheelDelta;
                var elem = $(e.currentTarget);

                if (delta > 0 && elem[0].scrollHeight - elem.scrollTop() == elem.outerHeight()) {
                    Annotationeer.nextDocument();
                }
                else if (delta < 0 && elem.scrollTop() == 0) {
                    Annotationeer.previousDocument();
                }
            });
        }

        // selected text listener
        var viewContainerMouseDown = false;
        var viewContainerMouseMove = false;

        viewerContainer.mousedown(function() {
            viewContainerMouseDown = true;
        });

        viewerContainer.mousemove(function() {
            if (viewContainerMouseDown)
                viewContainerMouseMove = true;
        });

        viewerContainer.mouseup(function(e) {
            if (PageManager.selectionTextType == Annotation.TYPE_TEXT_INSERT && e.target.childNodes[0]) {
                var test = Util.findClickedWord(e.target.childNodes[0], e.clientX, e.clientY);
                if (test) {
                    // Create text insert annotation.
                    e.preventDefault();
                    PageManager.createAnnotationTextInsert(e, rotateAngle);
                }
            } else  if ((viewContainerMouseMove && PageManager.getSelectedText() != '')) {
                e.preventDefault();
                if (!$('#textSelectMode').hasClass('toggled'))
                    PageManager.createSelectText();
            }

            viewContainerMouseDown = false;
            viewContainerMouseMove = false;
        });

        // This will open a context menu when in text select mode only.
        viewerContainer.on('contextmenu', function(e) {
            if (Util.isMobile() ||  PageManager.selectionTextType > 0)
                return;

            if (PageManager.isWithinSelectionBound(e.clientX, e.clientY)) {
                if (Default.BOOKMARK_ENABLE && e.which == 3)
                    PageManager.displaySelectedTextMenu(e);
            }

            e.preventDefault();
        });

        // this checks if text selection mode is enabled, ensures when user scrolls that
        // all text layers can be text selectable
        viewerContainer.scroll(function () {
            if ($('button#textHighlight').hasClass('toggled') ||
                $('button#textUnderline').hasClass('toggled') ||
                $('button#textStrikeThrough').hasClass('toggled') ||
                $('button#textReplace').hasClass('toggled'))
            {
                if (pages) {
                    for (var p in pages) {
                        if (!pages.hasOwnProperty(p))
                            continue;

                        pages[p].canvas.style.pointerEvents = 'none';
                        PageManager.getPageContainer(pages[p].pageIndex + 1).children('.freeTextLayer').addClass('hidden');
                    }
                }
            }
        });

        $(document).keydown(function(e) {
            // escape == 27
            if (e.keyCode == 27) {
                if (PageManager.boxAnnotationGuide && PageManager.boxAnnotationGuide.dummy) {
                    var page = pages[Default.canvasIdName + (PageManager.boxAnnotationGuide.pageIndex + 1)];
                    try {
                        var annotation = page.canvasAnnotations[page.canvasAnnotations.length - 1];
                        if (annotation && annotation.dummy) {
                            page.canvasAnnotations.splice(page.canvasAnnotations.length - 1, 1);
							page.invalidate();
                        }
                    } catch (e) { }
                }

                PageManager.closeAllDropDown();
                resetVar();
            }
            // delete == 46
            else if (e.keyCode == 46) {
                if ($('.remodal-is-opened').length > 0 || PageManager.selectedAnnotations.length == 0)
                    return;

                setTimeout(function() {
                    var writeable = false;
                    for (var i = PageManager.selectedAnnotations.length; i-- > 0; ) {
                        if (!PageManager.selectedAnnotations[i].isReadOnly()) {
                            writeable = true;
                            break;
                        }
                    }

                    if (!writeable)
                        return;

                    var exec = function() {
                        for (var i = PageManager.selectedAnnotations.length; i-- > 0; ) {
                            if (!PageManager.selectedAnnotations[i].isReadOnly() &&
                                PageManager.selectedAnnotations[i].comments[0].username == Annotationeer.getUsername())
                            {
                                Annotationeer.deleteAnnotation(PageManager.selectedAnnotations[i]);
                                PageManager.selectedAnnotations.splice(i, 1);
                                PageManager.selectedAnnotations.splice(i, 1);
                            }
                        }
                    };

                    if (Default.ALERT_DELETE) {
                        if (Default.ALERT_BEAUTIFY) {
                            PageManager.showConfirm(Message.ANNOTATION_DELETE_ASK, exec);
                            return;
                        }
                        else {
                            if (!PageManager.showConfirm(Message.ANNOTATION_DELETE_ASK))
                                return;
                        }
                    }

                    exec();
                }, 100);
            }
        });

        $('input#colorPalette').on('input', function() {
            Default.DRAW_COLOR_FOREGROUND = $(this).val();
            $('#color_fg').css('background', $(this).val());
            PageManager.consoleLog('Changed foreground color: ' + Default.DRAW_COLOR_FOREGROUND);
            if (PageManager.boxAnnotationGuide)
                PageManager.boxAnnotationGuide.color = Default.DRAW_COLOR_FOREGROUND;
        });

        $('input#backgroundPalette').on('input', function() {
            Default.DRAW_COLOR_BACKGROUND = $(this).val();
            $('#color_bg').css('background', $(this).val());
            PageManager.consoleLog('Changed background color: ' + Default.DRAW_COLOR_BACKGROUND);
             if (PageManager.boxAnnotationGuide)
                PageManager.boxAnnotationGuide.backgroundColor = Default.DRAW_COLOR_BACKGROUND;
        });
    });
})();

/**
 * Initializes Annotationeer.
 * @function
 * @memberof Annotationeer
 */
 Annotationeer.init = function() {
    $('input#aPageNumber').val('');
    $('input#colorPalette').val(Default.DRAW_COLOR_FOREGROUND);
    $('input#backgroundPalette').val(Default.DRAW_COLOR_BACKGROUND);
    $('div#color_fg').css('background-color', Default.DRAW_COLOR_FOREGROUND);
    $('div#color_bg').css('background-color', Default.DRAW_COLOR_BACKGROUND);

	Annotationeer.updateNavPageButtonState();

    if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
        window.onbeforeunload = function() {
            if (Annotationeer.getModifiedAnnotations().length > 0)
                return Message.SAVE_UNSAVED;
        };
    }

    // Disable screen shot feature if not IE because of its strict CORS
    // security, it will not allow canvas.toDataURL().
    if (Util.isIE()) {
        $('#toggleScreenShot').remove();
        $('#capturePage').remove();
    }

    // Remove console.warn messages from PDF.JS
    console.warn = function() { };

    PageManager.initWebAppPreferences();

    Annotationeer.downloadAnnotations();
};

/**
 * <p>This is where you place code to download annotations from the server and place them in arrays annotations and
 * highlightTexts. Once populated, loop through these 2 array objects and add them to the PDF pages.</p>
 * @function
 * @memberof Annotationeer
 * @param {boolean} reload Reload annotations in the sidebar after retrieving data from the backend.
 */
Annotationeer.downloadAnnotations = function(reload) {
    annotations = [];
    var annotationURL = Url.restUrl + 'annotations/' + Annotationeer.currentDocument.documentId;
    $.ajax({
        dataType: 'json',
        url: annotationURL,
        async: false,
        headers: {
            'username': Annotationeer.getUsername()
        },
        success: function(response) {
            for (var i=0; i<response.settings.length; i++) {
                if (response.settings[i].key == 'ANNOTATIONS_READ_ONLY') {
                    Default.ANNOTATIONS_READ_ONLY = response.settings[i].value == 'true';
                }
            }

            for (var i=0; i<response.annotations.length; i++) {
                var annotation = new Annotation();
                annotation.id = response.annotations[i].id;
                annotation.srno = parseInt(response.annotations[i].sr_no);
                annotation.annotationType = parseInt(response.annotations[i].annotation_type_id);
                annotation.pageIndex = parseInt(response.annotations[i].page_index);
                annotation.pageWidth = parseInt(response.annotations[i].page_width);
                annotation.pageHeight = parseInt(response.annotations[i].page_height);
                annotation.docId = response.annotations[i].doc_id;
                annotation.modified = '';
                annotation.readOnly = parseInt(response.annotations[i].read_only);
                annotation.readOnlyComment = parseInt(response.annotations[i].read_only_comment);
                annotation.calibrationLabel = response.annotations[i].calibration_label;
                annotation.calibrationValue = parseFloat(response.annotations[i].calibration_value);
                annotation.calibrationMeasurementType = parseFloat(response.annotations[i].calibration_measurement_type_id);
                annotation.measurementType = parseInt(response.annotations[i].measurement_type_id);
                annotation.lineStyle = parseInt(response.annotations[i].line_style_id);
                annotation.hasDimension = true;

                // Use global setting value if no value is set in the database
                if (annotation.measurementType == 0)
                    annotation.measurementType = Default.ANNOTATION_MEASUREMENT_TYPE_DEFAULT;

                // Parse annotation string x, y, w, h
                var c_ = response.annotations[i].coordinate.split(',');
                annotation.x = parseFloat(c_[0]);
                annotation.y = parseFloat(c_[1]);
                annotation.w = parseFloat(c_[2]);
                annotation.h = parseFloat(c_[3]);
                annotation.origX = annotation.x;
                annotation.origY = annotation.y;
                annotation.origW = annotation.w;
                annotation.origH = annotation.h;

                annotation.formFieldName = response.annotations[i].form_field_name;
                annotation.formFieldValue = response.annotations[i].form_field_value;
                annotation.text = response.annotations[i].text;
                annotation.fontSize = response.annotations[i].font_size;
                annotation.font = response.annotations[i].font;
                annotation.lineWidth = response.annotations[i].line_width;
                annotation.opacity = response.annotations[i].opacity;

                annotation.dateCreated = moment(response.annotations[i].date_created).toDate();
                annotation.dateModified = moment(response.annotations[i].date_modified).toDate();

                if (annotation.annotationType == Annotation.TYPE_AUDIO)
                    annotation.audioAvailable = true;

                if (response.annotations[i].icon != '') annotation.setIconSource(response.annotations[i].icon, reload);
                // We do if condition here so default values would not be overwritten
                if (response.annotations[i].color) annotation.color = response.annotations[i].color;
                if (response.annotations[i].background_color) annotation.backgroundColor = response.annotations[i].background_color;

                if (annotation.annotationType == Annotation.TYPE_TEXT)
                    PageManager.setFreeTextImageToAnnotation(annotation, annotation.id);

                // Drawing Positions
                for (var d=0; d<response.annotations[i].drawing_positions.length; d++) {
                    var dp = new DrawingPosition();
                    dp.id = response.annotations[i].drawing_positions[d].id;
                    dp.annotationId = response.annotations[i].drawing_positions[d].annotation_id;

                    var dc_ = response.annotations[i].drawing_positions[d].coordinate.split(',');
                    dp.x = parseFloat(dc_[0]);
                    dp.y = parseFloat(dc_[1]);
                    dp.origX = dp.x;
                    dp.origY = dp.y;

                    annotation.drawingPositions.push(dp);
                }

                // Highlight Text Rect
                for (var d=0; d<response.annotations[i].highlight_text_rects.length; d++) {
                    var htr = new HighlightTextRect();
                    htr.id = response.annotations[i].highlight_text_rects[d].id;
                    htr.annotationId = response.annotations[i].highlight_text_rects[d].annotationId;

                    var dc_ = response.annotations[i].highlight_text_rects[d].coordinate.split(',');
                    htr.left = parseFloat(dc_[0]);
                    htr.top = parseFloat(dc_[1]);
                    htr.width = parseFloat(dc_[2]);
                    htr.height = parseFloat(dc_[3]);
                    htr.right = htr.left + htr.width;
                    htr.bottom = htr.top + htr.height;
                    htr.origLeft = htr.left;
                    htr.origTop = htr.top;
                    htr.origWidth = htr.width;
                    htr.origHeight = htr.height;
                    htr.origRight = htr.right;
                    htr.origBottom = htr.bottom;
                    htr.setDomRotateAngle(response.annotations[i].highlight_text_rects[d].dom_rotate_angle, rotateAngle);

                    annotation.highlightTextRects.push(htr);
                }

                // Comments
                for (var c=0; c<response.annotations[i].comments.length; c++) {
                    if (c == 0)
                        annotation.comments = [];

                    var comment = new Comment();
                    comment.id = response.annotations[i].comments[c].id;
                    comment.annotationId = response.annotations[i].comments[c].annotation_id;
                    comment.username = response.annotations[i].comments[c].username;
                    comment.user_name = response.annotations[i].comments[c].first_name+' '+response.annotations[i].comments[c].last_name ;
                  //  comment.user_name = response.annotations[i].comments[c].user_name;
                    comment.comment = response.annotations[i].comments[c].comment;
                    comment.dateCreated = moment(response.annotations[i].comments[c].date_created).toDate();
                    comment.dateModified = moment(response.annotations[i].comments[c].date_modified).toDate();
                    comment.parentId = response.annotations[i].comments[c].parent_id;
                    comment.modified = '';

                    // Review status
                    if (response.annotations[i].comments[c].review_statuses)
                        for (var s=0; s<response.annotations[i].comments[c].review_statuses.length; s++) {
                            var rs = new ReviewStatus();
                            rs.id = response.annotations[i].comments[c].review_statuses[s].id;
                            rs.commentId = response.annotations[i].comments[c].review_statuses[s].comment_id;
                            rs.status = response.annotations[i].comments[c].review_statuses[s].status;
                            rs.reviewedBy = response.annotations[i].comments[c].review_statuses[s].reviewed_by;
                            rs.dateReviewed = moment(response.annotations[i].comments[c].review_statuses[s].date_reviewed).toDate();
                            rs.modified = '';
                            comment.reviewStatuses.push(rs);
                        }

                    annotation.comments.push(comment);
                }

                annotations.push(annotation);
            }

            if (response.digital_signatures)
                for (var i=0; i<response.digital_signatures.length; i++) {
                    var ds = new DigitalSignature();
                    ds.id = response.digital_signatures[i].id;
                    ds.username = response.digital_signatures[i].username;
                    ds.signature = response.digital_signatures[i].signature;
                    ds.width = response.digital_signatures[i].width;
                    ds.height = response.digital_signatures[i].height;
					PageManager.addDigitalSignatureToList(ds);
                }

            if (Default.STAMP_CUSTOM_ENABLED && response.stamps)
                for (var i=0; i<response.stamps.length; i++) {
					PageManager.addStampToList(response.stamps[i].id, response.stamps[i].stamp, response.stamps[i].width, response.stamps[i].height);
                }

			if (response.bookmarks)
				for (var i=0; i<response.bookmarks.length; i++) {
					var bookmark = new Bookmark();
					bookmark.id = response.bookmarks[i].id;
					bookmark.pageIndex = parseInt(response.bookmarks[i].page_index);
					bookmark.docId = response.bookmarks[i].doc_id;
					bookmark.parentId = response.bookmarks[i].parent_id;
					bookmark.label = response.bookmarks[i].label;
					bookmark.zoom =  parseFloat(response.bookmarks[i].zoom);
					bookmark.pageX =  parseFloat(response.bookmarks[i].pageX);
					bookmark.pageY =  parseFloat(response.bookmarks[i].pageY);
					bookmark.pageWidth =  parseFloat(response.bookmarks[i].page_width);
					bookmark.pageHeight =  parseFloat(response.bookmarks[i].page_height);
					bookmark.createdBy = response.bookmarks[i].created_by;
					bookmark.dateCreated = moment(response.bookmarks[i].date_created).toDate();
					bookmark.dateModified = moment(response.bookmarks[i].date_modified).toDate();
					BookmarkManager.bookmarks.push(bookmark);
				}

            if (Util.isFunction(Annotationeer.a389nnotationsDownloaded))
                Annotationeer.annotationsDownloaded()

            if (reload)
                PageManager.reloadAnnotations();
        }
    });
};

/**
 * Function to run when the 'pagerendered' event is triggered.
 * @function
 * @memberof Annotationeer
 * @param {number} pageIndex The page index.
 * @param {decimal} scale The current zoom percent of the Viewer.
 */
Annotationeer.runAfterPageRendered = function(pageIndex, scale) {
	PageManager.consoleLog('Annotationeer.runAfterPageRendered() page: ' + (pageIndex + 1) + ', scale: ' + scale);

    // By default, annotation toolbar is disabled until at least a page is rendered.
    PageManager.setAnnotationToolbarState('enabled');

    new Promise(function() {
        // Hide context menu if any
        $.contextMenu('destroy',  '#' + Default.canvasIdName + pageIndex);

        // Add a div.freeTextLayer since free text even for 1 liner will not be a prompt anymore.
        var freeTextLayer = $('<div></div>');
        freeTextLayer.addClass('freeTextLayer');
		PageManager.getPageContainer(pageIndex + 1).append(freeTextLayer);
		PageManager.getPageContainer(pageIndex + 1).addClass('selectTextDisabled');

        /**
         * Add position: relative to div.page# with attribute data-page-number > canvasWrapper element
         * so that any text annotation that will go beyond the parent's boundary will be displayed as cut off.
         */
		PageManager.getPageContainer(pageIndex + 1).find('.canvasWrapper').css('position', 'relative');

        var page = pageIndex + 1;
        var canvasOfPdfPage = $('canvas#page' + page);

        // We draw the watermark here because at least it gets called once. In IE/Edge, if we draw
        // the watermark on every mouse move, the performance is very slow because of
        // Page.prototype.getTextHeight() which uses div layer to measure text height.
        if (Default.WATERMARK_SHOW && canvasOfPdfPage.css('transform') === 'none') {
            var pdfPageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex);
            PageManager.drawWatermarkOnCanvas(canvasOfPdfPage[0], pdfPageView.scale , rotateAngle ? rotateAngle : 0);
        }

        // Ensure only 1 Annotationeer canvas per page in case user does a mouse wheel.
        var canvasWrapper = PageManager.getPageContainer(pageIndex + 1).find('.canvasWrapper');
        canvasWrapper.find('canvas[id="' + Default.canvasIdName + page + '"]').remove();
        
        var clone = $('<canvas></canvas>');
        clone.attr('id', Default.canvasIdName + page);
        clone.css('z-index', '' + Default.zIndex);
        clone.attr('width', canvasOfPdfPage.css('width'));
        clone.attr('height', canvasOfPdfPage.css('height'));
		canvasWrapper.append(clone);

        var anPage = new Page();
        anPage.pageIndex = pageIndex;
        anPage.init(Default.canvasIdName + page);
        pages[Default.canvasIdName + page] = anPage;

        // We include button#textInsert because it needs the 2 lines of code but ignores
        // setting the selectTextDisabled class attribute.
        if ($('button#textHighlight').hasClass('toggled') ||
            $('button#textUnderline').hasClass('toggled') ||
            $('button#textStrikeThrough').hasClass('toggled') ||
            $('button#textSelectMode').hasClass('toggled') ||
            $('button#textInsert').hasClass('toggled') ||
            $('button#textReplace').hasClass('toggled'))
        {
            anPage.canvas.style.pointerEvents = 'none';
			PageManager.getPageContainer(pageIndex + 1).children('.freeTextLayer').addClass('hidden');

            if (!$('button#textInsert').hasClass('toggled'))
                PageManager.getPageContainer(pageIndex + 1).removeClass('selectTextDisabled');
        }

         // We added the scale parameter here because it seems when this pagerender event is emitted,
        // The PDFViewerApplication.pdfViewer.currentScale does not get updated consistently by the
        // time this function is called. Probably happens on heavy pages. This is the quickest
        // workaround, getting the PDF.JS page object's details that includes the scale value.
        Annotationeer.loadAnnotations(pageIndex, true, false, scale);

        resetVar(true, true);
    });
};

/**
 * Function to run when the 'pagechanged' event is triggered.
 * @function
 * @memberof Annotationeer
 * @param {number} page The page number.
 */
Annotationeer.pageChanged = function(page) {
	//noinspection JSUnusedAssignment
    PageManager.consoleLog('Annotationeer.pageChanged() page: ' + page);

    var page = 0;
    for (var i=0; i<Annotationeer.pdfDocuments.length; i++) {
        if (Annotationeer.pdfDocuments[i] == Annotationeer.currentDocument) {
            page += PDFViewerApplication.pdfViewer.currentPageNumber;
            $('#aPageNumber').val(page);
			Annotationeer.updateNavPageButtonState();
            break;
        }
        else
            page += Annotationeer.pdfDocuments[i].totalPages;
    }

    /**
     * Temporarily disable for now. Problem with pageAnnotation# div layer does not get recreated
     */
    //PageManager.resetPagesIfOffScreen();
};

/**
 * Opens the form where user can add comments.
 * @function
 * @memberof Annotationeer
 * @param {Annotation} annotation The annotation object.
 * @param {string} key What kind the comment is for. e.g. edit, reply.
 * @param {object} comment The comment object to point to if it already exists.
 */
Annotationeer.openAnnotationForm = function(annotation, key, comment) {

	PageManager.consoleLog('Annotationeer.openAnnotationForm()');
    angular.element($('#popupContainer')).scope().setAnnotation(annotation, key, comment);
};

// Annotationeer.openAnnotationForm2 = function(annotation, key, comment) {
// 	PageManager.consoleLog('Annotationeer.openAnnotationForm2()');
//   PageManager.consoleLog(annotation);
//   PageManager.consoleLog(key);PageManager.consoleLog(comment);
//     angular.element($('#popupfabricationContainer')).scope().setAnnotation(annotation, key, comment);
//     //angular.element($('#popupContainer')).scope().setAnnotation(annotation, key, comment);
// };

/**
 * Saves an annotation.
 * @function
 * @memberof Annotationeer
 * @param {Annotation} annotation The annotation object.
 * @param {string} text If annotation highlight/box falls within an area that has text in it, include text in case you want to
 * also save what text is beneath the annotation area.
 * @param {boolean} doNotTriggerEvent If true, trigger annotation event. Default.CREATE_ANNOTATION_EVENT will still override this.
 */
Annotationeer.saveAnnotation = function(annotation, text, doNotTriggerEvent) {
	PageManager.consoleLog('Annotationeer.saveAnnotation(): processing annotation: ' + annotation.id + (text ? ', with text: ' + text : ''));

    var showCommentForm = annotation.id == 0;
    /**
     * If SAVE_ALL_ANNOTATIONS_ONE_TIME is true, then just update annotations in code and setting temporary
     * id to make each annotation as unique. When saved to server, it will check for the modified variable
     * and see if the value is changed. If changed, then treat it as id == 0 to insert data.
     */
    // Change code here to save to web server
    if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
        /**
         * If this is a new annotation, then id will be negative so that it will not
         * conflict with id that are in the early + value like those < 10.
         */
        if (annotation.id == 0) {
            annotation.id = -annotations.length - 1;
        }
        else if (annotation.modified == '') {
            annotation.modified = 'update';
        }

		PageManager.updateAnnotationListAfterSave(annotation, showCommentForm, doNotTriggerEvent);
    }
    else {
        // We pass a copy as request object so that certain properties can be modified like free text's iconSrc needs to be null.
        var copyAnnotation = Annotation.clone(annotation);
        copyAnnotation.icon = null;

        if (copyAnnotation.annotationType == Annotation.TYPE_TEXT)
            copyAnnotation.iconSrc = null;


        $.ajax({
            url: Url.restUrl + Url.annotationSaveUrl,
            type: 'post',
            data: Util.jsonStringify(copyAnnotation),
            contentType: 'application/json',
            dataType: 'json',
            cache: false,
            success: function(response) {
              //PageManager.consoleLog(response);
                annotation.id = response.id;
                annotation.modified = response.modified;
                annotation.oldModified = response.oldModified ? response.oldModified : '';
                annotation.user_name = response.user_name;
                annotation.srno = response.sr_no;
                for (var c=0; c<response.comments.length; c++) {
                    annotation.comments[c].id = response.comments[c].id;
                    annotation.comments[c].modified = response.comments[c].modified;
                    annotation.comments[c].user_name=response.comments[c].user_name;
                    // comment.username = response.annotations[i].comments[c].username;
                    // comment.user_name = response.annotations[i].comments[c].first_name+' '+response.annotations[i].comments[c].last_name ;

                    for (var s=0; s<response.comments[c].reviewStatuses.length; s++) {
                        annotation.comments[c].reviewStatuses[s].id = response.comments[c].reviewStatuses[s].id;
                        annotation.comments[c].reviewStatuses[s].modified = response.comments[c].reviewStatuses[s].modified;
                    }
                }

				PageManager.updateAnnotationListAfterSave(annotation, showCommentForm, false);
				PageManager.consoleLog('Save successful. Id: ' + annotation.id);
            },
            error: function(xhr, status, error) {
				PageManager.consoleLog('Error saving annotation: ' + error);
            }
        });
    }

    PageManager.initFilterOptions();
};

/**
 * Delete annotation from annotations array and the page's canvas.
 * @function
 * @memberof Annotationeer
 * @param {Annotation} annotation The annotation object.
 * @param {boolean} fromAngular Indicates if this action came from the sidebar list.
 * @param {boolean} doNotTriggerEvent If true, trigger annotation event. Default.CREATE_ANNOTATION_EVENT will still override this.
 */
Annotationeer.deleteAnnotation = function(annotation, fromAngular, doNotTriggerEvent) {
	PageManager.consoleLog('Annotationeer.deleteAnnotation(): id: ' + annotation.id);

    if (annotation.isReadOnly())
        return;

    if (Default.ANNOTATIONS_TOOLTIP && annotation.tooltip) {
        if (typeof annotation.tooltip.hide == 'function')
            annotation.tooltip.hide();

        annotation.tooltip = undefined;
    }

    PageManager.hideContextMenu();

    /**
     * If doNotTriggerEvent is true, then this means that the delete annotation event was triggered
     * after the call to the server, hence there should be no request to the server for this.
     */
    if (!Default.SAVE_ALL_ANNOTATIONS_ONE_TIME && !doNotTriggerEvent) {
        $.ajax({
            url: Url.restUrl + Url.annotationDeleteUrl + '/' + annotation.id,
            type: 'delete',
            data: Util.jsonStringify(annotation),
            contentType: 'application/json',
            dataType: 'json',
            cache: false,
            success: function() {
				PageManager.consoleLog('Delete successful');
            },
            error: function(xhr, status, error) {
				PageManager.consoleLog('Error deleting annotation: ' + error);
            }
        });
    }

    var page = pages[Default.canvasIdName + (annotation.pageIndex + 1)];
    if (page)
        for (var j=0; j<page.canvasAnnotations.length; j++) {
            if (page.canvasAnnotations[j].id != annotation.id)
                continue;

            page.canvasAnnotations.splice(j, 1);
            page.invalidate();
            break;
        }

    for (var i=0; i<annotations.length; i++) {
        if (annotations[i].id == annotation.id) {
            if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
                if (annotations[i].id <= 0)
                    annotations.splice(i, 1);
                else
                    annotations[i].modified = 'delete';
            }
            else
                annotations.splice(i, 1);

            break;
        }
    }

    if (annotation.annotationType == Annotation.TYPE_TEXT) {
        $('#' + Default.ANNOTATION_ID_PREFIX_FREE_TEXT + annotation.id).remove();
    }
    else if (annotation.isFormField()) {
        $('#form' + annotation.id).remove();
    }
    else if (Default.ANNOTATION_SELECTABLE_TEXT_AS_DIV && annotation.isSelectableTextType()) {
        var divs = PageManager.getPageContainer(annotation.pageIndex + 1).find('.canvasWrapper').children('div[id="' + Default.ANNOTATION_ID_PREFIX_HIGHLIGHT_TEXT + annotation.id + '"]');
        for (var d=0; d<divs.length; d++) {
            $(divs[d]).remove();
        }
    }

    if (!fromAngular)
        angular.element($('#annotationListContainer')).scope().$digest();

    if (Default.CREATE_ANNOTATION_EVENTS && !doNotTriggerEvent) {
		PageManager.createAnnotationEvent(annotation, 'delete');
    }

    PageManager.removeSelectedAnnotation(annotation);
    PageManager.initFilterOptions();
};

/**
 * Edits the annotation's comments and opens up the comment form.
 * @function
 * @memberof Annotationeer
 * @param {object} annotation The annotation object.
 * @param {string} key Indicates if this is edit or reply which will affect the UI of the annotation popup window
 * @param {object} comment Identifies which comment to modify.
 */
Annotationeer.editAnnotation = function(annotation, key, comment) {
  PageManager.consoleLog(annotation);
  //PageManager.consoleLog(annotation);
	PageManager.consoleLog('Annotationeer.editAnnotation(): id: ' + annotation.id + ', key: ' + key);

    if (!annotation.canContainComments())
        return;

    // Since measuring type annotations and free text has its caption as its root comment, running this
    // function will result in opening up the comments popup as reply.
    if (annotation.hasMeasuring() || annotation.annotationType == Annotation.TYPE_TEXT) {
        // If comment is null, then comment is root that is not editable.
        if (!comment && !annotation.readOnlyComment)
            key = 'reply';
    }

    // We destroy the context menu for this menu item because if annotation type is TYPE_TEXT,
    // the alert() will overlap the context menu. This is a hack.
    $.contextMenu('destroy',  '#' + Default.canvasIdName + (annotation.pageIndex + 1));

	Annotationeer.openAnnotationForm(annotation, key, comment);
};

/**
 * Loads annotations that belong to a specific page.
 * @function
 * @memberof Annotationeer
 * @param {number} pageIndex The page index.
 * @param {boolean} preserveSelection Preserve selection if any.
 * @param {boolean} resizeTypeTextDimension This parameter only applies to Annotation.TYPE_TEXT since you can now resize the
 * font size and text so its area should be recalculated.
 * @oaram {decimal} scale The current zoom value of the viewer.
 */
Annotationeer.loadAnnotations = function(pageIndex, preserveSelection, resizeTypeTextDimension, scale) {
    var page = pages[Default.canvasIdName + (pageIndex + 1)];
    page.canvasAnnotations = [];

    if (!preserveSelection)
		PageManager.clearSelectedAnnotationArray();

    var canvasRect = {
        width: $(page.canvas).height(),
        height: $(page.canvas).width()
    };
    var scaleToUse = scale ? scale : PDFViewerApplication.pdfViewer.currentScale;

    for (var i=0; i<annotations.length; i++) {
        var annotation  = annotations[i];

        /**
         * This applies if option is Default.SAVE_ALL_ANNOTATIONS_ONE_TIME is true
         * so annotations will only be remove permanently once the user manually
         * saves the annotations.
         *
         * If they are not yet saved and page is re-rendered due to page orientation
         * or scale, do not add annotations to the page.
         */
        if (annotation.pageIndex != pageIndex || annotation.modified == 'delete')
            continue;

        if (annotation.annotationType == Annotation.TYPE_TEXT) {
             page.addText(annotation, rotateAngle, scaleToUse, resizeTypeTextDimension, true, true);
        }
        else if (annotation.isSelectableTextType()) {
            var pageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex);
            page.highlightText(annotation.annotationType, pageIndex, rotateAngle, scaleToUse,
                pageView, annotation, annotation.getHighlightTextColor());

            if (Default.ANNOTATION_SELECTABLE_TEXT_AS_DIV) {
                var divs = PageManager.getPageContainer(annotation.pageIndex + 1).find('.canvasWrapper').children('div[id="' + Default.ANNOTATION_ID_PREFIX_HIGHLIGHT_TEXT + '"]');
                for (var d=0; d<divs.length; d++) {
                    $(divs[d]).attr('id', Default.ANNOTATION_ID_PREFIX_HIGHLIGHT_TEXT + annotation.id);
                }
            }
        }
        else if (annotation.isFormField()) {
            page.addFormField(annotation, rotateAngle, scaleToUse, true, false, true);
        }
        else {
            page.addAnnotation(annotation, rotateAngle, scaleToUse, true, false, true);
        }
    }

    for (var i=0; i<page.canvasAnnotations.length; i++) {
        if (page.canvasAnnotations[i].annotationType == Annotation.TYPE_TEXT)
            page.canvasAnnotations[i].rotateText(canvasRect, rotateAngle, scaleToUse,
                $('#' + Default.ANNOTATION_ID_PREFIX_FREE_TEXT + page.canvasAnnotations[i].id));
        else if (page.canvasAnnotations[i].isFormField())
           page.canvasAnnotations[i].rotateText(canvasRect, rotateAngle, scaleToUse,
                $('#' + Default.ANNOTATION_ID_PREFIX_FORM_FIELD + page.canvasAnnotations[i].id));
        else
            page.canvasAnnotations[i].rotate(canvasRect, rotateAngle, scaleToUse);

        // Replace annotation with updated dimensions in the PageManager.selectedAnnotations array.
        if (preserveSelection) 
            for (var s=0; s<PageManager.selectedAnnotations.length; s++) {
                if (PageManager.selectedAnnotations[s].id === page.canvasAnnotations[i].id) {
                    PageManager.selectedAnnotations.splice(s, 1, page.canvasAnnotations[i]);
                    break;
                }
            }

       if (!page.canvasAnnotations[i].drawingPositions)
            continue;

        for (var p=0; p<page.canvasAnnotations[i].drawingPositions.length; p++) {
            page.canvasAnnotations[i].drawingPositions[p].rotate(canvasRect, rotateAngle, scaleToUse);
        }
    }

    if (page.canvasAnnotations.length > 0)
    	page.invalidate(scale);
};

/**
 * Shows context menu for annotation or comment related actions.
 * @function
 * @memberof Annotationeer
 * @param {Annotation} annotationsSelected The annotation object.
 * @param {decimal} px The x coordinate.
 * @param {decimal} py The y coordinate.
 * @param {object} selector DOM Selector to search for the element to anchor it on.
 * @param {boolean} trigger If context menu will be triggered by left or right mouse button click.
 * @param {object} comment The comment object.
 * @param {boolean} reviewStatusMenuItemsOnly If true, only menu items related to review status will be shown.
 */
Annotationeer.displayAnnotationMenu = function(annotationsSelected, px, py, selector, trigger, comment, reviewStatusMenuItemsOnly) {
  // PageManager.consoleLog(annotationsSelected);
	PageManager.consoleLog('Annotationeer.displayAnnotationMenu()');

    var annotation = annotationsSelected.length > 0 ? annotationsSelected[0] : annotationsSelected;

    if (annotation.hidden)
        return;

	var commentToUse = comment ? comment : annotation.comments[0];
    var rs = commentToUse.reviewStatuses.length > 0 ?
		commentToUse.reviewStatuses[commentToUse.reviewStatuses.length - 1] : null;

    var items = {
        'screen_shot': { name: '<span data-l10n-id="screenshot_label">ScreenShot</span>', isHtmlName: true },
        'sep': '---------',
        'play': { name: '<span data-l10n-id="play_label">Play</span>', isHtmlName: true },
        'sep_audio': '---------',
        'view': { name: '<span data-l10n-id="view_label">View</span>', isHtmlName: true },
        // 'edit': { name: '<span data-l10n-id="edit_label">Edit</span>', isHtmlName: true },
        'reply': { name: '<span data-l10n-id="reply_label">Reply</span>', isHtmlName: true },
        'delete': { name: '<span data-l10n-id="delete_label">Delete</span>', isHtmlName: true },
        'sep_status': '---------',
        'status': {
            name: '<span data-l10n-id="status_label">Status</span>',
			isHtmlName: true,
            items: {
                'none': {
					name: '<span data-l10n-id="none_label">None</span>',
					className: rs && rs.status == 'none' ? 'review-status-chosen' : '',
					isHtmlName: true
				},
                'accepted': {
					name: '<span data-l10n-id="accepted_label">Accepted</span>',
					className: rs && rs.status == 'accepted' ? 'review-status-chosen' : '',
					isHtmlName: true
				},
                'cancelled': {
					name: '<span data-l10n-id="cancelled_label">Cancelled</span>',
					className: rs && rs.status == 'cancelled' ? 'review-status-chosen' : '',
					isHtmlName: true
				},
                'completed': {
					name: '<span data-l10n-id="completed_label">Completed</span>',
					className: rs && rs.status == 'completed' ? 'review-status-chosen' : '',
					isHtmlName: true
				},
                'rejected': {
					name: '<span data-l10n-id="rejected_label">Rejected</span>',
					className: rs && rs.status == 'rejected' ? 'review-status-chosen' : '',
					isHtmlName: true
				}
            }
        },
        'calibrate_prop': '---------',
        'calibrate': { name: '<span>Calibrate</span>', isHtmlName: true },
        'sep_prop': '---------',
        'properties': { name: '<span data-l10n-id="properties_label">Properties</span>', isHtmlName: true }
    };

    if (annotationsSelected.length > 1) {
        delete items.screen_shot;
        delete items.sep;
        delete items.view;
        delete items.edit;
        delete items.reply;
        delete items.sep_prop;
        delete items.properties;
    }

    if ((annotation.annotationType != Annotation.TYPE_HIGHLIGHT &&
        annotation.annotationType != Annotation.TYPE_BOX) || Util.isIE())
    {
        delete items.screen_shot;
        delete items.sep;
    }

    if (annotation.annotationType != Annotation.TYPE_AUDIO) {
        delete items.play;
        delete items.sep_audio;
    }

    /**
     * By default, measurement area annotation should have its root comment disabled since it is
     * not editable, mimicking Adobe Acrobat's behavior. Only replies are allowed for this type of
     * annotation.
     *
     * We also need to check if the comment object is undefined or not. If undefined, then this is
     * the root comment, hence cannot be edited.
     */
    if (annotation.hasMeasuring() || annotation.annotationType == Annotation.TYPE_TEXT) {
        if (!comment)
            delete items.edit;
    }

    // If current username is not the same as comment's username, then remove edit/delete options.
    if ((!comment && !Annotationeer.commentIsBySameUser(annotation.comments[0])) ||
        (comment && !Annotationeer.commentIsBySameUser(comment)))
    {
        delete items.edit;
        delete items.delete;
    }

    if (annotation.isReadOnly()) {
        delete items.sep_prop;
        delete items.properties;

    if (!comment)
            delete items.delete;
    }

    if (!annotation.canContainComments()) {
        delete items.edit;
        delete items.reply;
        delete items.view;

        if (comment)
            delete items.delete;
    }

    if (annotation.readOnlyComment) {
        delete items.edit;
        delete items.reply;

        if (comment)
            delete items.delete;
    }
    else {
        delete items.view;
    }

    if (!annotation.hasEditableProperties() || annotation.comments[0].username != Annotationeer.getUsername()) {
        delete items.sep_prop;
        delete items.properties;
    }

    if (!Default.COMMENT_FEATURE_STATUS_ENABLED || !annotation.isReviewStatusable()) {
        delete items.sep_status;
        delete items.status;
    }

    if (annotation.annotationType != Annotation.TYPE_MEASUREMENT_DISTANCE && annotation.annotationType != Annotation.TYPE_MEASUREMENT_AREA) {
        delete items.calibrate_prop;
        delete items.calibrate;
    }

	// If review status menu items only, then remove all menu items except these.
	if (reviewStatusMenuItemsOnly)
		Object.keys(items).forEach(function(itm) {
			if (itm != 'status')
				delete items[itm];
		});

    if (jQuery.isEmptyObject(items))
        return;

	$.contextMenu({
		selector: selector ? selector : ('canvas#' + Default.canvasIdName + (annotation.pageIndex + 1)),
		trigger: trigger ? trigger : 'none',
		zIndex: 99999,
		callback: function(key, options) {
			switch (key) {
				case 'play':
					Annotationeer.showPlayer(annotation);
					break;
				case 'edit':
				case 'reply':
				case 'view':
					Annotationeer.editAnnotation(annotation, key, key == 'edit' ? commentToUse : null);
					break;
				case 'delete':
					setTimeout(function() {
                        var exec = function() {
                            if (annotationsSelected.length) {
                                var i = annotationsSelected.length;
                                while (i--) {
                                    Annotationeer.deleteAnnotation(annotationsSelected[i]);
                                    annotationsSelected.splice(i, 1);
                                }
                            }
                            else {
                                if (comment)
                                    Annotationeer.deleteComment(annotation, comment);
                                else
                                    Annotationeer.deleteAnnotation(annotation);
                            }
                        };

						if (Default.ALERT_DELETE) {
                            if (Default.ALERT_BEAUTIFY) {
                                PageManager.showConfirm(Message.ANNOTATION_DELETE_ASK, exec);
                                return;
                            }
                            else {
                                if (!PageManager.showConfirm(Message.ANNOTATION_DELETE_ASK))
                                    return;
                            }
						}

                        exec();
					}, 100);
					break;
				case 'screen_shot':
					PageManager.screenShot(annotation);
					break;
				case 'properties':
					PageManager.openAnnotationPropertiesForm(annotation);
					break;
                case 'calibrate':
                    angular.element($('div#calibrateContainer')).scope().showCalibrateForm(annotation);
                    break;
				default:
					if (options.items.status && options.items.status.items)
						for (var item in options.items.status.items) {
							if (key == item) {
								// Since we are doing translation, remove tag and get html text.
								var rs = new ReviewStatus();
								rs.status = item;
                                rs.modified = 'insert';
                                Annotationeer.saveReviewStatus(annotation, commentToUse, rs);
                                break;
							}
						}
					break;
			}
		},
		items: items,
		events: {
			show: function() {
				PageManager.translateEachL10n($('ul.context-menu-list').first());
			},
			hide: function() {
				$.contextMenu('destroy',  selector ? selector : 'canvas#' + Default.canvasIdName + (annotation.pageIndex + 1));
			}
		}
	});

	// If there is an overridden selector value, it means the context menu should anchor itself
	// to that DOM element. Else, on the default canvas.
	if (!selector)
		$('#' + Default.canvasIdName + (annotation.pageIndex + 1)).contextMenu({x: px, y: py});
};

/**
 * Go to page.
 * @function
 * @memberof Annotationeer
 * @param {number} page The page number;
 */
Annotationeer.goToPage = function (page) {
	PageManager.consoleLog('Annotationeer.goToPage() page: ' + page);
    if ((Annotationeer.pdfDocuments.length > 1 && Annotationeer.aTotalPages >= page && page > 0) ||
        page > 0)
    {
        PDFViewerApplication.pdfViewer.currentPageNumber = page;
    }
};

/**
 * Go to next page.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.nextPage = function() {
	PageManager.consoleLog('Annotationeer.nextPage()');
    var page = PDFViewerApplication.pdfViewer.currentPageNumber;

    if (page >= PDFViewerApplication.pdfViewer.pagesCount && Annotationeer.pdfDocuments.length == 0)
        return;

    if (page < PDFViewerApplication.pdfViewer.pagesCount) {
        page++;
    }
    else if (Annotationeer.pdfDocuments.length > 1 && page + 1 > PDFViewerApplication.pdfViewer.pagesCount) {
		Annotationeer.nextDocument();
        return;
    }

	Annotationeer.goToPage(page);
};

/**
 * Go to previous page.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.previousPage = function() {
	PageManager.consoleLog('Annotationeer.previousPage()');
    var page = PDFViewerApplication.pdfViewer.currentPageNumber;

    if (page <= 0) {
        return;
    }

    if ((page - 1) >= 1) {
        page--;
    }
    else if (Annotationeer.pdfDocuments.length > 1 && page - 1 == 0) {
		Annotationeer.previousDocument();
        return;
    }

	Annotationeer.goToPage(page);
};

/**
 * Go to next document.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.nextDocument = function() {
	PageManager.consoleLog('Annotationeer.nextDocument()');
    for (var d=0; d<Annotationeer.pdfDocuments.length; d++) {
        if (Annotationeer.pdfDocuments[d] == Annotationeer.currentDocument) {
            if (d + 1 <= Annotationeer.pdfDocuments.length - 1) {
				Annotationeer.reloadPDF(Annotationeer.pdfDocuments[d + 1], 1);
            }
            return;
        }
    }
};

/**
 * Go to previous document.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.previousDocument = function() {
	PageManager.consoleLog('Annotationeer.previousDocument()');
    for (var d=0; d<Annotationeer.pdfDocuments.length; d++) {
        if (Annotationeer.pdfDocuments[d] == Annotationeer.currentDocument) {
            if (d > 0) {
				Annotationeer.reloadPDF(Annotationeer.pdfDocuments[d - 1], Annotationeer.pdfDocuments[d - 1].totalPages);
            }
            return;
        }
    }
};

/**
 * Update navigation page button state.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.updateNavPageButtonState = function() {
    if (Annotationeer.pdfDocuments.length == 1)
        return;

    var aNextPage = $('#aNextPage');
    var aPreviousPage = $('#aPreviousPage');

    if (PDFViewerApplication.loading) {
        aNextPage.prop('disabled', true);
       aPreviousPage.prop('disabled', true);
        return;
    }

    var currentPage = PDFViewerApplication.pdfViewer.currentPageNumber;
    var pages = PDFViewerApplication.pdfViewer.pagesCount;

    aNextPage.prop('disabled', false);
    aPreviousPage.prop('disabled', false);

    if (pages <= 1) {
        aNextPage.prop('disabled', true);
        aPreviousPage.prop('disabled', true);
    } else if (currentPage >= pages) {
        aNextPage.prop('disabled', true);
    }
    else if (currentPage <= 1) {
        aPreviousPage.prop('disabled', true);
    }

    if (Annotationeer.currentDocument) {
        if (currentPage == 1)
            aPreviousPage.prop('disabled', Annotationeer.currentDocument.isFirst);
        else if (currentPage == pages)
            aNextPage.prop('disabled', Annotationeer.currentDocument.isLast);
    }

    var aNumPages = $('#aNumPages');
    if (PDFViewerApplication.l10n) {
        PDFViewerApplication.l10n.get('of_pages', { pagesCount: Annotationeer.aTotalPages }, 'of {{pagesCount}}').then(
            function(msg) {
                aNumPages.html(msg);
            });
    } else {
        aNumPages.html('of ' + Annotationeer.aTotalPages);
    }
};

/**
 * This function will select an annotation after a PDF is loaded.
 * @function
 * @memberof Annotationeer
 * @param {number} annotationId The annotation id.
 * @param {number} pageIndex The page index.
 */
Annotationeer.selectAnAnnotationOnLoad = function(annotationId, pageIndex) {
    PDFViewerApplication.pdfViewer.currentPageNumber = pageIndex + 1;
    for (var a=0; a<annotations.length; a++) {
        if (annotations[a].id == annotationId) {
            PageManager.addSelectedAnnotation(annotations[a]);
            PageManager.scrollToAnnotationInCanvas(annotations[a]);
            setTimeout(function() {
                PageManager.scrollToAnnotationInList(annotations[a]);
            }, 50);
            break;
        }
    }
};

/**
 * Show audio player.
 * @function
 * @memberof Annotationeer
 * @param {Annotation} annotation The annotation object.
 */
Annotationeer.showPlayer = function(annotation) {
	PageManager.consoleLog('showPlayer()');
    angular.element($('#playerContainer')).scope().showPlayer(annotation);
};

/**
 * <p>Since {@link PDFViewerApplication.initialBookmark| PDFViewerApplication.initialBookmark()} does not work,
 * we override the query string value of window.history.location.target.hash.</p>
 * @function
 * @memberof Annotationeer
 * @param {object} page The page object.
 */
Annotationeer.setInitialPageBookmark = function(page) {
	PageManager.consoleLog('setInitialPageBookmark(): ' + page);
    try {
        var hash = window.history.state.target.hash;
        hash = hash && !hash.startsWith('?') ? '?' : '';
        // Remove ? after updating query string parameter with new value
        window.history.state.target.hash = Util.updateQueryStringParameter(hash, 'page', page).substring(1);
		PageManager.consoleLog('hash: ' + window.history.state.target.hash);
    } catch (e) { }
};

/**
 * <p>Back when the free text creation logic was to show a browser prompt window for the user to input text,
 * This is now not used, although an option is available in default.js in case user wishes to have this
 * feature.</p>
 * @function
 * @memberof Annotationeer
 * @param {object} page The page object where the free text will be placed after user mouse click and prompt input.
 * @param {decimal} mouseX The x coordinate on the page.
 * @param {decimal} mouseY The y coordinate on the page.
 * @param {boolean} existingAnnotation If true, then get the text value and use this as default value of prompt window.
 */
Annotationeer.showTextInput = function(page, mouseX, mouseY, existingAnnotation) {
    var textInput = ' ';

    //if (!existingAnnotation && Default.TYPE_TEXT_1_LINER)
    //    textInput = prompt('Enter text (Limit: ' + Default.ANNOTATION_TYPE_TEXT_CHAR_LIMIT + ' characters)');

    if (textInput || existingAnnotation) {
        var annotation = existingAnnotation ? existingAnnotation : new Annotation();
        if (!existingAnnotation) {
            annotation.pageIndex = page.pageIndex;
            annotation.x = existingAnnotation ? existingAnnotation.x : mouseX;
            annotation.y = existingAnnotation ? existingAnnotation.y : mouseY;
            annotation.text = textInput;
            annotation.color = existingAnnotation ? existingAnnotation.color : Default.DRAW_COLOR_FOREGROUND;
            annotation.annotationType = Annotation.TYPE_TEXT;
        }

        annotation.hasDimension = false;

        if (existingAnnotation) {
            // remove annotation from page, then re-add
            for (var i=0; i<page.canvasAnnotations.length; i++) {
                if (page.canvasAnnotations[i].id == existingAnnotation.id) {
                    page.canvasAnnotations.splice(i, 1);
                    $('#' + Default.ANNOTATION_ID_PREFIX_FREE_TEXT + existingAnnotation.id).remove();
                    break;
                }
            }
        }

        page.addText(annotation, rotateAngle, PDFViewerApplication.pdfViewer.currentScale, true, true, false, true);
    }

    resetVar(false, true);
};

/**
 * Returns an array of unsaved annotations that were modified by the user.
 * @function
 * @memberof Annotationeer
 * @returns {Array<Annotation>}
 */
Annotationeer.getModifiedAnnotations = function() {
	//PageManager.consoleLog('Annotationeer.getModifiedAnnotations()');
    var changedAnnotations = [];
    var changed = false;
    // PageManager.consoleLog(parent.doc);
    // PageManager.consoleLog(parent.my_var);
    // PageManager.consoleLog(parent.filename);
    // PageManager.consoleLog(parent.inspection_type);
    // PageManager.consoleLog(parent.user_id);


    PageManager.consoleLog('Annotationeer'+ annotations);
    for (var a=0; a<annotations.length; a++) {
        changed = annotations[a].modified != '';


        // Set icon property to null because in mobile browsers, this results in a
        // Converting circular structure to JSON error message.
        var copyAnnotation = jQuery.extend(true, {}, annotations[a]);
         copyAnnotation.icon = null;

         // copyAnnotation.project = parent.my_var;
         // copyAnnotation.document_id = parent.doc;
         // copyAnnotation.document = parent.filename;
         // copyAnnotation.inspection_type = parent.inspection_type;
         // copyAnnotation.user_id = parent.user_id;

        if (changed) {

            // If annotation type is free text, set iconSrc property to null as well so that it will not be saved to database.
            // This is because we attached a base 64 image to its icon property to be used in print preview purposes.
            if (copyAnnotation.annotationType == Annotation.TYPE_TEXT)
                copyAnnotation.iconSrc = null;

            changedAnnotations.push(copyAnnotation);
        }
        else {
            root:
            for (var c=0; c<annotations[a].comments.length; c++) {

                if (annotations[a].comments[c].modified != '') {
                    changed = true;
                    changedAnnotations.push(copyAnnotation);
                    break;
                }

                for (var r=0; r<annotations[a].comments[c].reviewStatuses.length; r++) {
                    if (annotations[a].comments[c].reviewStatuses[r].modified != '') {
                        changed = true;
                        changedAnnotations.push(copyAnnotation);
                        break root;
                    }
                }
            }
        }
    }
    return changedAnnotations;
};

/**
 * Save all annotations to backend.
 * @function
 * @memberof Annotationeer
 */
Annotationeer.saveAllAnnotationsToServer = function() {
    resetVar(false, true);

	PageManager.consoleLog('Annotationeer.saveAllAnnotationsToServer(): annotations size: ' + (annotations ? annotations.length : 0));
    if (!annotations || annotations.length == 0)
        return;

    // Variable changedAnnotations will always return an array
    var changedAnnotations = Annotationeer.getModifiedAnnotations();

	  PageManager.consoleLog('changedAnnotations size: ' + changedAnnotations.length);

    if (changedAnnotations.length == 0) {
		PageManager.showAlert(Message.ANNOTATION_SAVE_NOTHING, 'info');
        return;
    }

    $.ajax({
        url: Url.restUrl + Url.annotationSaveUrl,
        type: 'post',
        data: Util.jsonStringify(changedAnnotations),
        contentType: 'application/json',
        dataType: 'json',
        cache: false,
        success: function(response) {
            for (var r=0; r<response.length; r++) {
                var json = typeof response[r] == 'string' ? JSON.parse(response[r]) : response[r];
                for (var a=0; a<annotations.length; a++) {
                    // Can be updated or inserted value
                    if (json.oldId && json.modified == '' && json.oldId == annotations[a].id) {
                        annotations[a].id = json.id;
                        annotations[a].comments = json.comments;
                        annotations[a].oldId = json.oldId;

                        if (annotations[a].iconSrc) {
                            if (!annotations[a].icon) annotations[a].icon = new Image();
                            annotations[a].setIconSource(annotations[a].iconSrc);
                        }

                        /**
                         * The oldModified property of the annotation object is set to update if
                         * Default.CREATE_ANNOTATION_EVENTS is true. This is because when an annotation
                         * is first added to the canvas, its action is insert. However, when the save button
                         * is clicked, the annotation already exists in the canvas, hence its oldModified property
                         * value is now update because we only need to update the newly generated id.
                         */
                        if (Default.CREATE_ANNOTATION_EVENTS) {
                            annotations[a].oldModified = 'update';
							PageManager.createAnnotationEvent(annotations[a]);
                        }

                        annotations[a].modified = json.modified;

                        if (json.drawingPositions.length > 0) {
                            for (var dp=0; dp<json.drawingPositions.length; dp++) {
                                annotations[a].drawingPositions[dp].id = json.drawingPositions[dp].id;
                            }
                        }

                        if (annotations[a].annotationType == Annotation.TYPE_TEXT) {
							PageManager.getPageContainer(annotations[a].pageIndex + 1).find('.canvasWrapper').
                                children('div[id="' + Default.ANNOTATION_ID_PREFIX_FREE_TEXT + annotations[a].oldId + '"]').
                                each(function()
                                {
                                    $(this).attr('id', Default.ANNOTATION_ID_PREFIX_FREE_TEXT + annotations[a].id);
                                });
                        }
                        else if (annotations[a].isFormField()) {
							PageManager.getPageContainer(annotations[a].pageIndex + 1).find('.canvasWrapper').
                                children('div[id="' + Default.ANNOTATION_ID_PREFIX_FORM_FIELD + annotations[a].oldId + '"]').
                                each(function()
                                {
                                    $(this).attr('id', Default.ANNOTATION_ID_PREFIX_FORM_FIELD + annotations[a].id);
                                });
                        }

                        if (json.highlightTextRects.length > 0) {
                            for (var htr=0; htr<json.highlightTextRects.length; htr++) {
                                /**
                                 * If old id is 0, then the id is newly generated, hence we also rename the id
                                 * in the Div element.
                                 */
                                if (Default.ANNOTATION_SELECTABLE_TEXT_AS_DIV && annotations[a].oldId <= 0) {
									PageManager.getPageContainer(annotations[a].pageIndex + 1).find('.canvasWrapper').
                                        children('div[id="' + Default.ANNOTATION_ID_PREFIX_HIGHLIGHT_TEXT + annotations[a].oldId + '"]').
                                        each(function()
                                    {
                                        $(this).attr('id', Default.ANNOTATION_ID_PREFIX_HIGHLIGHT_TEXT + annotations[a].id);
                                    });
                                }
                                annotations[a].highlightTextRects[htr].id = json.highlightTextRects[htr].id;
                            }
                        }

                        if (json.comments.length > 0) {
                            for (var c=0; c<json.comments.length; c++) {
								if (json.comments[c].oldModified == 'delete' && json.comments[c].id == annotations[a].comments[c].id) {
									annotations[a].comments.splice(c, 1);
								}
								else {
									annotations[a].comments[c].id = json.comments[c].id;

									if (json.comments[c].reviewStatuses)
										for (var r=0; r<json.comments[c].reviewStatuses.length; r++) {
											annotations[a].comments[c].reviewStatuses[r].id = json.comments[c].reviewStatuses[r].id;
											annotations[a].comments[c].reviewStatuses[r].modified = json.comments[c].reviewStatuses[r].modified;
										}
								}
                            }
                        }

                        break;
                    }
                    else if (json && json.oldModified == 'delete' && json.id == annotations[a].id) {
                        annotations.splice(a, 1);
                        break;
                    }
                }
            }
			Annotationeer.resetAllAnnotationsChangedProperty(true);

			PageManager.showAlert(Message.ANNOTATION_SAVE_SUCCESS, 'success');
        },
        error: function(xhr, status, error) {
			PageManager.showAlert(Message.ANNOTATION_SAVE_ERROR + error, 'error');
        }
    });
};

/**
 * <p>For DEMO purposes in case there is no web service to communicate to we have to simulate
 * the annotations are saved correctly.</p>
 * @function
 * @memberof Annotationeer
 */
Annotationeer.resetAllAnnotationsChangedProperty = function(success) {
    if (!success)
        return;

    for (var a=0; a<annotations.length; a++) {
        annotations[a].modified = '';
        for (var c=0; c<annotations[a].comments.length; c++) {
            annotations[a].comments[c].modified = '';
        }

        annotations.splice(a, 1, annotations[a]);
    }
};

//noinspection JSUnusedLocalSymbols
/**
 * Capture the screenshot as a base64 image string. Code should be overridden in override.js.
 * @function
 * @memberof Annotationeer
 * @param {object} canvas The canvas object.
 */
Annotationeer.saveScreenShot = function(canvas) {
    // window.open and location.href blocks data:image// in browsers because of security issues.
    // To retrieve and use the image, call canvas.toDataURL();
    //PageManager.consoleLog(canvas.toDataURL());
	PageManager.showAlert(Message.FEATURE_NOT_OVERRIDDEN, 'info');
};

//noinspection JSUnusedLocalSymbols
/**
 * Capture the page with annotation as a base64 image string. Code should be overridden in override.js.
 * @function
 * @memberof Annotationeer
 * @param {object} canvas The canvas object.
 */
Annotationeer.saveCapturePage = function(canvas) {
    //PageManager.consoleLog(canvas.toDataURL());
	PageManager.showAlert(Message.FEATURE_NOT_OVERRIDDEN, 'info');
};

/**
 * Saves digital signature to server and simulates a create annotation action.
 * @function
 * @memberof Annotationeer
 * @param {object} signaturePad The signature pad object.
 * @param {boolean} justUse If true, it will not save the signature.
 * @param {Annotation} annotation If not null, signature will be saved and updated to this annotation.
 */
Annotationeer.saveDigitalSignature = function(signaturePad, justUse, annotation) {
    var ds = new DigitalSignature();
    ds.signature = 'data:' + signaturePad.jSignature('getData', 'svgbase64');

    // Get width and height because output does not return it. We instead parse the SVG element.
    var xml = signaturePad.jSignature('getData', 'image/svg+xml')[1];
    var start = xml.indexOf('<svg');
    var svg = $(xml.substring(start, xml.indexOf('</svg>') + 6));
    ds.width = svg.attr('width');
    ds.height = svg.attr('height');

    if (annotation) {
        annotation.setIconSource(ds.signature);
        annotation.modified = 'update';
        pages[Default.canvasIdName + (annotation.pageIndex + 1)].invalidate();
    }

    if (justUse) {
        if (!annotation)
			PageManager.createAnnotation($('#digital_signature'), Annotation.TYPE_DIGITAL_SIGNATURE, ds.signature, ds.width, ds.height);

        return;
    }

    $.ajax({
        url: Url.restUrl + Url.signatureSaveUrl,
        type: 'post',
        headers: {
            'username': Annotationeer.getUsername()
        },
        data: Util.jsonStringify(ds),
        contentType: 'application/json',
        dataType: 'json',
        cache: false,
        success: function(response) {
            ds.id = response.id;
            ds.signature = response.signature;
            ds.width = response.width;
            ds.height = response.height;
            ds.username = Annotationeer.getUsername();

            // Add to digital signature list.
			PageManager.addDigitalSignatureToList(ds);

            // After saving to server and adding it to signature list, user is now ready to place the signature.
            if (!annotation)
				PageManager.createAnnotation($('#digital_signature'), Annotation.TYPE_DIGITAL_SIGNATURE, ds.signature, ds.width, ds.height);

			PageManager.consoleLog('Save signature successful. Id: ' + ds.id);
        },
        error: function(xhr, status, error) {
			PageManager.consoleLog('Error saving signature: ' + error);
        }
    });
};

/**
 * Delete signature.
 * @function
 * @memberof Annotationeer
 * @param {number} id The id of the signature.
 */
Annotationeer.deleteDigitalSignature = function(id) {
    $.ajax({
        url: Url.restUrl + Url.signatureDeleteUrl + '/' + id,
        type: 'delete',
        headers: {
            'username': Annotationeer.getUsername()
        },
        contentType: 'application/json',
        cache: false,
        success: function() {
            $('ul#digitalSignatureList li#' + id).remove();
			PageManager.consoleLog('Delete signature successful.');
        },
        error: function(xhr, status, error) {
			PageManager.consoleLog('Error deleting signature: ' + error);
        }
    });
};

/**
 * <p>Used native Javascript code instead of JQuery ajax because it does not work.
 * This one does though.</p>
 * @function
 * @memberof Annotationeer
 */
Annotationeer.exportToPDF = function() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', Url.restUrl + Url.exportAnnotationUrl + '/' + Annotationeer.pdfDocumentInfo.documentId, true);
    xhr.responseType = 'blob';
    xhr.setRequestHeader('username', Annotationeer.getUsername());
    xhr.onload = function() {
        if (this.status == 200) {
           var blob = this.response;
            var link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = Annotationeer.pdfDocumentInfo.documentId + '.pdf';
            link.click();
        }
    };
    xhr.send();
};

// TODO: Right now I have no idea yet how to transfer code here since the uploading
// feature is dependent on Dropzone code.
Annotationeer.saveStamp = function() {

};

/**
 * Delete stamp.
 * @function
 * @memberof Annotationeer
 * @param {number} id The id of the stamp.
 */
Annotationeer.deleteStamp = function(id) {
    $.ajax({
        url: Url.restUrl + Url.stampDeleteUrl + '/' + id,
        type: 'delete',
        headers: {
            'username': Annotationeer.getUsername()
        },
        contentType: 'application/json',
        cache: false,
        success: function() {
            $('#stampList').find('li#' + id).remove();
			PageManager.consoleLog('Delete stamp successful.');
        },
        error: function(xhr, status, error) {
			PageManager.consoleLog('Error deleting stamp: ' + error);
			PageManager.showAlert(Message.STAMP_DELETE_ERROR, 'error');
        }
    });
};

/**
 * Delete comment.
 * @function
 * @memberof Annotationeer
 * @param {object} annotation The annotation object.
 * @param {object} comment The comment object.
 * @param {boolean} fromAngular If this event is triggered from the sidebar or in the canvas context menu.
 */
Annotationeer.deleteComment = function(annotation, comment, fromAngular) {
	if (!Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
		$.ajax({
			url: Url.restUrl + Url.commentDeleteUrl.replace('[annotation_id]', annotation.id) + '/' + comment.id,
			type: 'delete',
			data: Util.jsonStringify(annotation),
			contentType: 'application/json',
			dataType: 'json',
			cache: false,
			success: function() {
				window.PageManager.updateAnnotationComment(annotation);
				// Also call this refresh digest on the sidebar so that there will be no blinking.
				angular.element('#annotationListContainer').scope().$digest();
			},
			error: function() {
				PageManager.showAlert(Message.COMMENT_DELETE_ERROR, 'error');
			}
		});
	}

	for (var a=0; a<annotations.length; a++) {
		if (annotations[a].id == annotation.id) {
			for (var c=0; c<annotations[a].comments.length; c++) {
				if (annotations[a].comments[c].id == comment.id) {
					if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
						if (annotations[a].comments[c].id <= 0)
							annotations[a].comments.splice(c, 1);
						else
							annotations[a].comments[c].modified = 'delete';
					}
					else
						annotations[a].comments.splice(c, 1);

					break;
				}
			}

			break;
		}
	}

	if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME && !fromAngular)
		angular.element('#annotationListContainer').scope().$digest();

	if (Default.CREATE_ANNOTATION_EVENTS) {
		PageManager.createAnnotationEvent(annotation, 'delete', comment);
	}
};

/**
 * Reload pdf without refreshing the browser.
 * @function
 * @memberof Annotationeer
 * @param {object} pdfDocument The PDF document.
 * @param {object} page The page object.
 */
Annotationeer.reloadPDF = function(pdfDocument, page) {
	PageManager.consoleLog('Annotationeer.reloadPDF(): ' + page);
	/**
	 * Progress bar not shown when reloaded
	 * issue still open - Progress bar display when changing PDFs #3090
	 * https://github.com/mozilla/pdf.js/issues/3090
	 */
	$('div.progress').removeClass('indeterminate');
    Annotationeer.currentDocument = pdfDocument;
	PDFViewerApplication.open(Url.docUrl + Annotationeer.currentDocument.documentId);
	Annotationeer.init();
	Annotationeer.setInitialPageBookmark(page);
};

/**
 * Helper method to check if comment is created by the same user.
 * @function
 * @memberof Annotationeer
 * @param comment
 * @returns {boolean}
 */
Annotationeer.commentIsBySameUser = function(comment) {
    return comment && comment.username == Annotationeer.getUsername();
};

/**
 * Save comment to backend. This is only called if {@link Default.SAVE_ALL_ANNOTATIONS_ONE_TIME} = false.
 * @function
 * @memberof Annotationeer
 * @param {object} annotation The annotation object.
 * @param {object} comment The comment object.
 */
Annotationeer.saveComment = function(annotation, comment) {

    $.ajax({
        url: Url.restUrl + Url.commentSaveUrl.replace('[annotation_id]', annotation.id),
        method: 'post',
        contentType: 'application/json',
        data: Util.jsonStringify(comment),
        success: function(response) {
            var json = typeof response == 'string' ? JSON.parse(response) : response;
            comment.id = json.id;
            comment.modified = json.modified;
            annotation.oldModified = json.oldModified ? json.oldModified : '';
            PageManager.updateAnnotationComment(annotation);
            $('#popupContainer').remodal().close();
        },
        error: function() {
            PageManager.showAlert(Message.COMMENT_SAVE_ERROR, 'error');
        }
    });
};

/**
 * Save the review status.
 * @function
 * @memberof Annotationeer
 * @param {object} annotation The annotation object.
 * @param {object} comment The comment object.
 * @param {object} rs The review status object.
 */
Annotationeer.saveReviewStatus = function(annotation, comment, rs) {
    if (Default.SAVE_ALL_ANNOTATIONS_ONE_TIME) {
        comment.reviewStatuses.push(rs);
        PageManager.updateAnnotationComment(annotation);
    }
    else {
        $.ajax({
            url: Url.restUrl + Url.reviewStatusSaveUrl.replace('[annotation_id]', comment.annotationId).replace('[comment_id]', comment.id),
            method: 'post',
            contentType: 'application/json',
            data: Util.jsonStringify(rs),
            success: function (response) {
                var json = JSON.parse(response);
                rs.id = json.id;
                rs.modified = json.modified;
                rs.oldModified = json.oldModified ? json.oldModified : '';
                comment.reviewStatuses.push(rs);
                PageManager.updateAnnotationComment(annotation);
            },
            error: function () {
                PageManager.showAlert(Message.REVIEW_STATUS_SAVE_ERROR, 'error');
            }
        });
    }
};

/**
 * Helper function to set the username.
 * @function
 * @memberof Annotationeer
 * @param username
 */
Annotationeer.setUsername = function(username) {
    Annotationeer.username = username;
};

/**
 * Helper function to return the username for new comments etc.
 * @function
 * @memberof Annotationeer
 * @returns {string}
 */
Annotationeer.getUsername = function() {
    return Annotationeer.username;
};
